---
layout: ../../layouts/PostLayout.astro
title: Two Sum Review
link: two-sum
pubDate: 2023-11-15
description: 'Reviewing the two sum problem.'
author: 'thddrew'
image:
    url: 'https://i.imgur.com/ltV7CEu.png'
    alt: 'An 8 bit style wave emoji.'
tags: ["leetcode", "learning"]
---
export const prerender = true;

<i>Make sure to implement the brute force solution first.</i>
<ul>
    <li>
        Trading space for speed is a common way to optimize algorithms. We will review the two-pass and the one-pass hashtable methods.
    </li>
    <li>
        The two-pass hashtable method can be used to solve in O(2n) time, which is analyzed as O(n).
        <ul>
            <li>
            <b>Use a hashtable to track the the value (key) and index (value) of elements we have visited.</b>\
            <i>Why a hashtable?</i>\
            The hashtable can be used to lookup data in constant time.\
            \
            <i>Why do we need to store the element and its index?</i>\
            For each iteration, we will know the complement of the pair we are looking for. We can use the hashtable to
            check, in constant time O(1), if we have already seen the complement.\
            </li>
            <li>
            <b>Check if the complement exists in the hashtable.</b>\
            <i>Why the complement?</i>\
            We are looking for pairs A and B where A + B = target. The hashtable is basically storing either the A or B of a pair.\
            ```
            Record<number, number>
            ---
            { A: <index of A> }
            ```
            In each iteration, we have a value that is either A or B and it is trivial to compute the other (complement). We check if and where we have already seen the complement using the hashtable.
            </li>
            <li>
                The tricky part was determining what key and value meant. A mental model for this could be:
                <blockquote>
                ðŸ§  I need to find an index in the array without looping through again. I know I can get a constant time lookup using a hashtable. What can I compute as my key that will give me the index I need?
                </blockquote>
            </li>
        </ul>
    </li>
    <li>
        The two-pass hashtable can be improved to one-pass by doing the lookup while building the hashtable.\
        What would help us come up with this optimization ourselves?
    </li>
    <blockquote>
        One pattern to recognize is that we do not need the full hashtable to check for the complement.
        Even if we don't find the complement in the early iterations, it will be found later.
        ex. [1, 2, 3, 4, 5] target = 4. In the beginning of the loop, we won't see 3 but we will see 1 when we get to 3 eventually.
    </blockquote>
</ul>

{/* Useful links:
<ul>
    <li><a href="https://www.youtube.com/watch?v=VEPCm3BCtik">What is the Two-Pointers Technique & How to use it? | Two-Pointers Approach Explained | Geekific</a></li>
</ul> */}